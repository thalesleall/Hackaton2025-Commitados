// chat.service.ts

import { IaService } from './IA.service';
import { DatabaseService } from './database.service';
import { AgendamentoService } from './agendamento.service';
import { Message, Conversation } from '../models/conversation.model';

export class ChatService {
  private agendamentoService: AgendamentoService;

  constructor(
    private iaService: IaService,
    private databaseService?: DatabaseService
  ) {
    this.agendamentoService = new AgendamentoService();
    console.log('ChatService inicializado.');
  }

  /**
   * Processa mensagem do usu√°rio com sistema de menu e salva no banco de dados
   */
  public async processUserMessage(
    mensagemDoUsuario: string, 
    idUsuario: string,
    conversationId?: string
  ): Promise<{
    resposta: string;
    conversation: Conversation;
  }> {
    console.log(`[ChatService] Processando mensagem de ${idUsuario}: "${mensagemDoUsuario}"`);
    
    let conversation: Conversation | null = null;

    // 1. Buscar ou criar conversa
    if (conversationId && this.databaseService) {
      // Buscar conversa existente
      conversation = await this.databaseService.getConversationById(conversationId);
      
      // Verificar se a conversa est√° inativa (mais de 10 minutos)
      if (conversation && this.databaseService.isConversationInactive(conversation)) {
        console.log(`[ChatService] Conversa ${conversationId} inativa h√° mais de 10 minutos. Iniciando nova conversa.`);
        conversation = null; // For√ßa cria√ß√£o de nova conversa
      } else if (conversation) {
        // IMPORTANTE: Conversas vindas do banco n√£o t√™m menu_state, definir com base no contexto
        conversation.menu_state = this.determineMenuState(conversation);
        console.log(`[ChatService] Conversa carregada do banco com estado: ${conversation.menu_state}`);
      }
    } else if (this.databaseService) {
      // Buscar conversa mais recente do usu√°rio
      conversation = await this.databaseService.findLatestConversationByUserId(idUsuario);
      
      // Verificar se a conversa est√° inativa (mais de 10 minutos)
      if (conversation && this.databaseService.isConversationInactive(conversation)) {
        console.log(`[ChatService] √öltima conversa do usu√°rio ${idUsuario} inativa h√° mais de 10 minutos. Iniciando nova conversa.`);
        conversation = null; // For√ßa cria√ß√£o de nova conversa
      } else if (conversation) {
        // IMPORTANTE: Conversas vindas do banco n√£o t√™m menu_state, definir com base no contexto
        conversation.menu_state = this.determineMenuState(conversation);
        console.log(`[ChatService] Conversa recente carregada com estado: ${conversation.menu_state}`);
      }
    }

    // 2. Se n√£o encontrou conversa, criar uma nova
    if (!conversation) {
      conversation = {
        id_usuario: idUsuario,
        id_conversa: `temp-${Date.now()}`, // ID tempor√°rio
        titulo: 'Menu de Atendimento',
        data_hora_inicio: new Date(),
        data_hora_ultima_mensagem: new Date(),
        status_conversa: 'aberta',
        mensagens: [],
        menu_state: 'menu', // Sempre inicia no menu
        agendamento_temp: {} // Dados tempor√°rios do agendamento
      };
    }

    // 3. Adicionar nova mensagem do usu√°rio
    const novaMensagemUsuario: Message = {
      remetente: 'usuario',
      texto: mensagemDoUsuario,
      data_hora: new Date()
    };

    conversation.mensagens.push(novaMensagemUsuario);

    // 4. SISTEMA DE MENU - Processar mensagem baseado no estado atual
    let respostaChatbot: string;
    
    console.log(`[ChatService] Estado atual: ${conversation.menu_state}, Mensagem: "${mensagemDoUsuario}", Total mensagens: ${conversation.mensagens.length}`);

    // PRIORIDADE 1: Comando "0" sempre volta ao menu principal
    if (mensagemDoUsuario.trim() === '0') {
      console.log('[ChatService] Comando "0" detectado - voltando ao menu');
      conversation.menu_state = 'menu';
      respostaChatbot = this.getMainMenu();
    }
    // PRIORIDADE 2: Estados espec√≠ficos j√° definidos
    else if (conversation.menu_state === 'ia_mode') {
      console.log('[ChatService] Processando no modo IA');
      respostaChatbot = await this.processIAMode(mensagemDoUsuario, conversation);
    }
    else if (conversation.menu_state === 'agendar_consulta' || 
             conversation.menu_state === 'agendar_especialidade' ||
             conversation.menu_state === 'agendar_medico' ||
             conversation.menu_state === 'agendar_data' ||
             conversation.menu_state === 'agendar_dados' ||
             conversation.menu_state === 'agendar_confirmacao') {
      console.log('[ChatService] Processando agendamento de consulta');
      respostaChatbot = await this.processAgendamento(mensagemDoUsuario, conversation);
    }
    else if (conversation.menu_state === 'autorizar_exame') {
      console.log('[ChatService] Processando autoriza√ß√£o de exame');
      respostaChatbot = this.processOtherMenus(mensagemDoUsuario, conversation);
    }
    // PRIORIDADE 3: Menu principal (estado 'menu' ou novo)
    else if (conversation.menu_state === 'menu' || !conversation.menu_state) {
      console.log('[ChatService] Processando sele√ß√£o do menu principal');
      
      // Verificar se √© uma conversa reiniciada por inatividade
      const isResumedConversation = conversationId && conversation.mensagens.length === 1;
      
      if (isResumedConversation) {
        respostaChatbot = `‚è∞ Sua sess√£o anterior foi finalizada por inatividade (10 minutos).

${this.getMainMenu()}`;
        // N√£o processar a mensagem como sele√ß√£o de menu neste caso
      } else {
        // Verificar se √© a primeira mensagem do usu√°rio
        const isFirstMessage = conversation.mensagens.length === 1; // S√≥ tem a mensagem atual do usu√°rio
        
        if (isFirstMessage) {
          // Primeira mensagem - mostrar greeting personalizado
          respostaChatbot = this.getWelcomeMessage();
        } else {
          // Processar normalmente como sele√ß√£o do menu
          respostaChatbot = await this.processMenuSelection(mensagemDoUsuario, conversation);
        }
      }
    }
    // FALLBACK: Estado desconhecido - volta ao menu
    else {
      console.log(`[ChatService] Estado desconhecido: ${conversation.menu_state} - voltando ao menu`);
      conversation.menu_state = 'menu';
      respostaChatbot = this.getMainMenu();
    }

    // 5. Adicionar resposta do chatbot
    const novaMensagemChatbot: Message = {
      remetente: 'chatbot',
      texto: respostaChatbot,
      data_hora: new Date()
    };

    conversation.mensagens.push(novaMensagemChatbot);
    conversation.data_hora_ultima_mensagem = new Date();

    // 6. Salvar conversa no banco de dados (preservar menu_state na mem√≥ria)
    if (this.databaseService) {
      try {
        // Preservar o estado do menu antes de salvar
        const currentMenuState = conversation.menu_state;
        
        const conversationToSave = { ...conversation };
        delete conversationToSave.menu_state; // Remove estado do menu antes de salvar no banco
        
        const savedConversation = await this.databaseService.saveConversation(conversationToSave);
        
        // Restaurar o estado do menu ap√≥s salvar
        savedConversation.menu_state = currentMenuState;
        conversation = savedConversation;
        
        console.log(`[ChatService] Conversa salva no banco: ${conversation.id_conversa} (estado: ${currentMenuState})`);
      } catch (error) {
        console.error('[ChatService] Erro ao salvar conversa:', error);
        // Continua mesmo se falhar ao salvar
      }
    }

    return {
      resposta: respostaChatbot,
      conversation: conversation
    };
  }

  /**
   * M√©todo simples para compatibilidade (sem salvar no banco)
   */
  public async processUserMessageSimple(mensagemDoUsuario: string, historicoMensagens?: Message[]): Promise<string> {
    console.log(`[ChatService] Processando mensagem simples: "${mensagemDoUsuario}"`);
    
    // Obter resposta da IA incluindo o hist√≥rico da conversa (se fornecido)
    const iaResponseText = await this.iaService.conversar(mensagemDoUsuario, historicoMensagens);

    return iaResponseText;
  }

  // =============================================
  // SISTEMA DE MENU - M√âTODOS PRIVADOS
  // =============================================

  /**
   * Retorna mensagem de boas-vindas para primeira intera√ß√£o
   */
  private getWelcomeMessage(): string {
    return `üëã Bem-vindo(a) ao atendimento da nossa cl√≠nica!

Sou seu assistente virtual e estou aqui para ajud√°-lo(a). Como posso ajud√°-lo hoje?

1. Tirar d√∫vidas (Com IA)
2. Agendar consulta
3. Autorizar exame

Digite o n√∫mero da op√ß√£o desejada ou 0 para voltar ao menu.

‚ÑπÔ∏è Sua sess√£o ser√° finalizada automaticamente ap√≥s 10 minutos de inatividade.`;
  }

  /**
   * Retorna o menu principal
   */
  private getMainMenu(): string {
    return `Ol√°! Como posso ajud√°-lo hoje?

1. Tirar d√∫vidas (Com IA)
2. Agendar consulta
3. Autorizar exame

Digite o n√∫mero da op√ß√£o desejada ou 0 para voltar ao menu.

‚ÑπÔ∏è Sua sess√£o ser√° finalizada automaticamente ap√≥s 10 minutos de inatividade.`;
  }

  /**
   * Processa sele√ß√£o do menu principal
   */
  private async processMenuSelection(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    const opcao = mensagemDoUsuario.trim();
    console.log(`[ChatService] Processando op√ß√£o do menu: "${opcao}"`);

    switch (opcao) {
      case '1':
        console.log('[ChatService] Ativando modo IA');
        conversation.menu_state = 'ia_mode';
        return `ü§ñ Modo IA ativado! Agora voc√™ pode fazer perguntas e eu responderei com intelig√™ncia artificial.

Voc√™ pode digitar qualquer d√∫vida m√©dica ou digite 0 para voltar ao menu principal.`;

      case '2':
        console.log('[ChatService] Ativando modo agendamento');
        conversation.menu_state = 'agendar_consulta';
        // Executar imediatamente o carregamento das especialidades
        return await this.iniciarAgendamento(conversation);

      case '3':
        console.log('[ChatService] Ativando modo autoriza√ß√£o');
        conversation.menu_state = 'autorizar_exame';
        return `üìã Autoriza√ß√£o de Exame

Em breve voc√™ ser√° direcionado para o sistema de autoriza√ß√£o de exames.

Digite 0 para voltar ao menu principal.`;

      default:
        // Op√ß√£o inv√°lida, mostra menu novamente
        console.log(`[ChatService] Op√ß√£o inv√°lida: "${opcao}"`);
        return `‚ùå Op√ß√£o inv√°lida. Por favor, escolha uma das op√ß√µes abaixo:

${this.getMainMenu()}`;
    }
  }

  /**
   * Processa mensagens no modo IA
   */
  private async processIAMode(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    console.log('[ChatService] Processando no modo IA');
    
    try {
      // Obter resposta da IA usando todo o hist√≥rico (exceto mensagens do menu)
      const mensagensParaIA = this.filterMessagesForIA(conversation.mensagens);
      const iaResponseText = await this.iaService.conversar(mensagemDoUsuario, mensagensParaIA);
      
      // Adiciona instru√ß√£o para voltar ao menu
      return `${iaResponseText}

---
üí° Digite 0 a qualquer momento para voltar ao menu principal.`;

    } catch (error) {
      console.error('[ChatService] Erro ao processar IA:', error);
      conversation.menu_state = 'menu';
      return `‚ùå Desculpe, ocorreu um erro ao processar sua pergunta. Retornando ao menu principal.

${this.getMainMenu()}`;
    }
  }

  /**
   * Processa sistema de agendamento completo
   */
  private async processAgendamento(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    try {
      // Inicializar dados tempor√°rios se n√£o existirem
      if (!conversation.agendamento_temp) {
        conversation.agendamento_temp = {};
      }

      switch (conversation.menu_state) {
        case 'agendar_consulta':
          return await this.iniciarAgendamento(conversation);
          
        case 'agendar_especialidade':
          return await this.processarEspecialidade(mensagemDoUsuario, conversation);
          
        case 'agendar_medico':
          return await this.processarMedico(mensagemDoUsuario, conversation);
          
        case 'agendar_data':
          return await this.processarData(mensagemDoUsuario, conversation);
          
        case 'agendar_dados':
          return await this.processarDadosPaciente(mensagemDoUsuario, conversation);
          
        case 'agendar_confirmacao':
          return await this.processarConfirmacao(mensagemDoUsuario, conversation);
          
        default:
          conversation.menu_state = 'menu';
          return this.getMainMenu();
      }
    } catch (error) {
      console.error('[ChatService] Erro no agendamento:', error);
      conversation.menu_state = 'menu';
      return `‚ùå Ocorreu um erro no sistema de agendamento. Retornando ao menu principal.

${this.getMainMenu()}`;
    }
  }

  /**
   * Processa outros menus (autorizar exame)
   */
  private processOtherMenus(mensagemDoUsuario: string, conversation: Conversation): string {
    if (conversation.menu_state === 'autorizar_exame') {
      return `üìã Voc√™ est√° no sistema de autoriza√ß√£o de exames.

Funcionalidade em desenvolvimento.

Digite 0 para voltar ao menu principal.`;
    }

    // Fallback - volta ao menu
    conversation.menu_state = 'menu';
    return this.getMainMenu();
  }

  /**
   * Filtra mensagens para enviar para a IA (remove mensagens do sistema de menu)
   */
  private filterMessagesForIA(mensagens: Message[]): Message[] {
    return mensagens.filter(msg => {
      // Remove mensagens do menu principal e instru√ß√µes de sistema
      if (msg.remetente === 'chatbot') {
        const texto = msg.texto.toLowerCase();
        return !texto.includes('como posso ajud√°-lo hoje') && 
               !texto.includes('modo ia ativado') &&
               !texto.includes('agendamento de consulta') &&
               !texto.includes('autoriza√ß√£o de exame') &&
               !texto.includes('op√ß√£o inv√°lida');
      }
      // Remove n√∫meros de op√ß√£o do menu (1, 2, 3, 0)
      if (msg.remetente === 'usuario') {
        const texto = msg.texto.trim();
        return !['0', '1', '2', '3'].includes(texto);
      }
      return true;
    });
  }

  /**
   * Determina o estado do menu com base no hist√≥rico da conversa
   */
  private determineMenuState(conversation: Conversation): 'menu' | 'ia_mode' | 'agendar_consulta' | 'autorizar_exame' | 
              'agendar_especialidade' | 'agendar_medico' | 'agendar_data' | 
              'agendar_dados' | 'agendar_confirmacao' {
    const mensagens = conversation.mensagens || [];
    
    // Se n√£o h√° mensagens, inicia no menu
    if (mensagens.length === 0) {
      return 'menu';
    }

    // Buscar a √∫ltima resposta do chatbot para determinar o estado
    const ultimasRespostasChatbot = mensagens
      .filter(msg => msg.remetente === 'chatbot')
      .slice(-5); // √öltimas 5 mensagens do chatbot para ter mais contexto

    for (const msg of ultimasRespostasChatbot.reverse()) {
      const texto = msg.texto.toLowerCase();
      
      // Verificar se ativou modo IA (buscar por indicadores espec√≠ficos)
      if (texto.includes('modo ia ativado') || 
          texto.includes('ü§ñ') || 
          (texto.includes('digite 0 a qualquer momento para voltar ao menu') && !texto.includes('como posso ajud√°-lo hoje'))) {
        console.log('[ChatService] Estado detectado: ia_mode');
        return 'ia_mode';
      }
      
      // Verificar se est√° em agendamento
      if (texto.includes('agendamento de consulta') || texto.includes('especialidades dispon√≠veis') || 
          texto.includes('m√©dicos dispon√≠veis') || texto.includes('datas e hor√°rios dispon√≠veis') ||
          texto.includes('dados do paciente') || texto.includes('confirma√ß√£o do agendamento')) {
        
        if (texto.includes('especialidades dispon√≠veis')) {
          console.log('[ChatService] Estado detectado: agendar_especialidade');
          return 'agendar_especialidade';
        } else if (texto.includes('m√©dicos dispon√≠veis')) {
          console.log('[ChatService] Estado detectado: agendar_medico');
          return 'agendar_medico';
        } else if (texto.includes('datas e hor√°rios dispon√≠veis')) {
          console.log('[ChatService] Estado detectado: agendar_data');
          return 'agendar_data';
        } else if (texto.includes('dados do paciente') || texto.includes('nome completo')) {
          console.log('[ChatService] Estado detectado: agendar_dados');
          return 'agendar_dados';
        } else if (texto.includes('confirma√ß√£o do agendamento')) {
          console.log('[ChatService] Estado detectado: agendar_confirmacao');
          return 'agendar_confirmacao';
        } else {
          console.log('[ChatService] Estado detectado: agendar_consulta');
          return 'agendar_consulta';
        }
      }
      
      // Verificar se est√° em autoriza√ß√£o
      if (texto.includes('autoriza√ß√£o de exame') || 
          (texto.includes('üìã') && texto.includes('funcionalidade em desenvolvimento'))) {
        console.log('[ChatService] Estado detectado: autorizar_exame');
        return 'autorizar_exame';
      }
      
      // Se menciona menu principal ou op√ß√£o inv√°lida, est√° no menu
      if (texto.includes('como posso ajud√°-lo hoje') || 
          texto.includes('op√ß√£o inv√°lida') ||
          texto.includes('digite o n√∫mero da op√ß√£o desejada')) {
        console.log('[ChatService] Estado detectado: menu');
        return 'menu';
      }
    }

    // Se n√£o conseguiu determinar, analisa a √∫ltima mensagem do usu√°rio
    const ultimaMsgUsuario = mensagens
      .filter(msg => msg.remetente === 'usuario')
      .slice(-1)[0];

    if (ultimaMsgUsuario) {
      const userInput = ultimaMsgUsuario.texto.trim();
      
      // Se a √∫ltima entrada foi uma op√ß√£o de menu, mas ainda n√£o foi processada
      if (['1', '2', '3'].includes(userInput)) {
        return 'menu'; // Ainda processando sele√ß√£o
      }
    }

    // Default: volta ao menu se n√£o conseguiu determinar
    console.log('[ChatService] N√£o foi poss√≠vel determinar estado do menu, voltando ao menu principal');
    return 'menu';
  }

  // =============================================
  // SISTEMA DE AGENDAMENTO - M√âTODOS PRIVADOS
  // =============================================

  /**
   * Inicia o processo de agendamento
   */
  private async iniciarAgendamento(conversation: Conversation): Promise<string> {
    try {
      const especialidades = await this.agendamentoService.getEspecialidades();
      
      if (especialidades.length === 0) {
        return `üìÖ Desculpe, n√£o h√° especialidades dispon√≠veis no momento.

Digite 0 para voltar ao menu principal.`;
      }

      conversation.menu_state = 'agendar_especialidade';
      
      let mensagem = `üè• **AGENDAMENTO DE CONSULTA**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ú® **Especialidades Dispon√≠veis:**

`;

      especialidades.forEach((esp, index) => {
        const cidades = esp.cidades.join(' ‚Ä¢ ');
        mensagem += `${index + 1}Ô∏è‚É£ **${esp.especialidade}**\n`;
        mensagem += `   üìç ${cidades}\n`;
        mensagem += `   üë®‚Äç‚öïÔ∏è ${esp.total_medicos} m√©dico${esp.total_medicos > 1 ? 's' : ''} dispon√≠vel${esp.total_medicos > 1 ? 'eis' : ''}\n\n`;
      });

      mensagem += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üî¢ Digite o **n√∫mero** da especialidade desejada
üîÑ Digite **0** para voltar ao menu principal`;

      return mensagem;

    } catch (error) {
      console.error('[ChatService] Erro ao iniciar agendamento:', error);
      return `‚ùå Erro ao carregar especialidades. Tente novamente.

Digite 0 para voltar ao menu principal.`;
    }
  }

  /**
   * Processa sele√ß√£o de especialidade
   */
  private async processarEspecialidade(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    try {
      const opcao = parseInt(mensagemDoUsuario.trim());
      
      if (isNaN(opcao)) {
        return `‚ùå **Op√ß√£o inv√°lida!**

üî¢ Por favor, digite o **n√∫mero** da especialidade desejada.
üîÑ Digite **0** para voltar ao menu principal.`;
      }

      const especialidades = await this.agendamentoService.getEspecialidades();
      
      if (opcao < 1 || opcao > especialidades.length) {
        return `‚ùå **N√∫mero inv√°lido!**

üî¢ Digite um n√∫mero entre **1** e **${especialidades.length}**.
üîÑ Digite **0** para voltar ao menu principal.`;
      }

      const especialidadeSelecionada = especialidades[opcao - 1].especialidade;
      conversation.agendamento_temp!.especialidade = especialidadeSelecionada;

      const medicos = await this.agendamentoService.getMedicosPorEspecialidade(especialidadeSelecionada);
      
      if (medicos.length === 0) {
        return `üìÖ N√£o h√° m√©dicos dispon√≠veis para ${especialidadeSelecionada}.

Digite 0 para voltar ao menu principal.`;
      }

      conversation.menu_state = 'agendar_medico';
      
      let mensagem = `ü©∫ **${especialidadeSelecionada.toUpperCase()}**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üë®‚Äç‚öïÔ∏è **M√©dicos Dispon√≠veis:**

`;

      medicos.forEach((medico, index) => {
        mensagem += `${index + 1}Ô∏è‚É£ **Dr(a). ${medico.nome}**\n`;
        mensagem += `   üìç ${medico.cidade}\n\n`;
      });

      mensagem += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üî¢ Digite o **n√∫mero** do m√©dico desejado
üîÑ Digite **0** para voltar ao menu principal`;

      return mensagem;

    } catch (error) {
      console.error('[ChatService] Erro ao processar especialidade:', error);
      return `‚ùå Erro ao carregar m√©dicos. Tente novamente.

Digite 0 para voltar ao menu principal.`;
    }
  }

  /**
   * Processa sele√ß√£o de m√©dico
   */
  private async processarMedico(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    try {
      const opcao = parseInt(mensagemDoUsuario.trim());
      
      if (isNaN(opcao)) {
        return `‚ùå Por favor, digite o n√∫mero do m√©dico desejado.

Digite 0 para voltar ao menu principal.`;
      }

      const medicos = await this.agendamentoService.getMedicosPorEspecialidade(
        conversation.agendamento_temp!.especialidade!
      );
      
      if (opcao < 1 || opcao > medicos.length) {
        return `‚ùå Op√ß√£o inv√°lida. Digite um n√∫mero entre 1 e ${medicos.length}.

Digite 0 para voltar ao menu principal.`;
      }

      const medicoSelecionado = medicos[opcao - 1];
      conversation.agendamento_temp!.medico_id = medicoSelecionado.id;
      conversation.agendamento_temp!.medico_nome = medicoSelecionado.nome;

      const horarios = await this.agendamentoService.getHorariosDisponiveis(medicoSelecionado.id);
      
      if (horarios.length === 0) {
        return `üìÖ **${medicoSelecionado.nome}** n√£o possui hor√°rios dispon√≠veis nos pr√≥ximos 30 dias.

Tente escolher outro m√©dico ou digite 0 para voltar ao menu principal.`;
      }

      conversation.menu_state = 'agendar_data';
      
      let mensagem = `üìÖ **${medicoSelecionado.nome.toUpperCase()}**
ü©∫ ${conversation.agendamento_temp!.especialidade} ‚Ä¢ üìç ${medicoSelecionado.cidade}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚è∞ **Datas e Hor√°rios Dispon√≠veis:**

`;

      // Agrupar por data
      const horariosPorData = new Map<string, typeof horarios>();
      horarios.forEach(h => {
        if (!horariosPorData.has(h.data)) {
          horariosPorData.set(h.data, []);
        }
        horariosPorData.get(h.data)!.push(h);
      });

      let contador = 1;
      const datasDisponiveis = Array.from(horariosPorData.entries()).slice(0, 10); // Mostrar apenas 10 primeiras datas

      datasDisponiveis.forEach(([data, horariosData]) => {
        const primeiroHorario = horariosData[0];
        const todosHorarios = horariosData.map(h => this.agendamentoService.formatarHorario(h.horario_inicio)).join(' ‚Ä¢ ');
        mensagem += `${contador}Ô∏è‚É£ **${primeiroHorario.data_formatada}**\n`;
        mensagem += `   üïê ${todosHorarios}\n\n`;
        contador++;
      });

      mensagem += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üî¢ Digite o **n√∫mero** da data desejada
üîÑ Digite **0** para voltar ao menu principal`;

      return mensagem;

    } catch (error) {
      console.error('[ChatService] Erro ao processar m√©dico:', error);
      return `‚ùå Erro ao carregar hor√°rios. Tente novamente.

Digite 0 para voltar ao menu principal.`;
    }
  }

  /**
   * Processa sele√ß√£o de data/hor√°rio
   */
  private async processarData(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    try {
      const opcao = parseInt(mensagemDoUsuario.trim());
      
      if (isNaN(opcao)) {
        return `‚ùå Por favor, digite o n√∫mero da data desejada.

Digite 0 para voltar ao menu principal.`;
      }

      const horarios = await this.agendamentoService.getHorariosDisponiveis(
        conversation.agendamento_temp!.medico_id!
      );

      // Agrupar por data (mesma l√≥gica do m√©todo anterior)
      const horariosPorData = new Map<string, typeof horarios>();
      horarios.forEach(h => {
        if (!horariosPorData.has(h.data)) {
          horariosPorData.set(h.data, []);
        }
        horariosPorData.get(h.data)!.push(h);
      });

      const datasDisponiveis = Array.from(horariosPorData.entries()).slice(0, 10);
      
      if (opcao < 1 || opcao > datasDisponiveis.length) {
        return `‚ùå Op√ß√£o inv√°lida. Digite um n√∫mero entre 1 e ${datasDisponiveis.length}.

Digite 0 para voltar ao menu principal.`;
      }

      const [dataSelecionada, horariosData] = datasDisponiveis[opcao - 1];
      
      // Se h√° apenas um hor√°rio, seleciona automaticamente
      if (horariosData.length === 1) {
        const horario = horariosData[0];
        conversation.agendamento_temp!.agenda_id = horario.agenda_id;
        conversation.agendamento_temp!.data_selecionada = dataSelecionada;
        conversation.agendamento_temp!.horario_selecionado = horario.horario_inicio;
        
        conversation.menu_state = 'agendar_dados';
        return this.solicitarDadosPaciente(conversation);
      }

      // Se h√° m√∫ltiplos hor√°rios, deixar o usu√°rio escolher
      conversation.agendamento_temp!.data_selecionada = dataSelecionada;
      
      let mensagem = `üìÖ **${horariosData[0].data_formatada}**

Escolha um hor√°rio:

`;

      horariosData.forEach((horario, index) => {
        const horarioFormatado = this.agendamentoService.formatarHorario(horario.horario_inicio);
        mensagem += `${index + 1}. ${horarioFormatado}\n`;
      });

      mensagem += `\nDigite o n√∫mero do hor√°rio desejado ou 0 para voltar ao menu principal.`;

      return mensagem;

    } catch (error) {
      console.error('[ChatService] Erro ao processar data:', error);
      return `‚ùå Erro ao processar data. Tente novamente.

Digite 0 para voltar ao menu principal.`;
    }
  }

  /**
   * Solicita dados do paciente
   */
  private solicitarDadosPaciente(conversation: Conversation): string {
    conversation.menu_state = 'agendar_dados';
    
    return `üìù **DADOS DO PACIENTE**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ú® Estamos quase finalizando seu agendamento!

Para concluir, preciso de algumas informa√ß√µes:

üë§ Digite seu **nome completo**:`;
  }

  /**
   * Processa dados do paciente
   */
  private async processarDadosPaciente(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    const input = mensagemDoUsuario.trim();

    if (!conversation.agendamento_temp!.paciente_nome) {
      // Primeira etapa: receber nome
      if (input.length < 3) {
        return `‚ùå **Nome muito curto!**

üë§ Digite seu **nome completo** (m√≠nimo 3 caracteres).`;
      }

      conversation.agendamento_temp!.paciente_nome = input;
      return `üìû **Perfeito, ${input}!**

Agora digite seu **telefone com DDD**:

üí° Exemplo: (11) 99999-9999`;
    } else {
      // Segunda etapa: receber telefone
      const telefoneRegex = /^\(?[1-9]{2}\)?\s?[0-9]{4,5}-?[0-9]{4}$/;
      
      if (!telefoneRegex.test(input.replace(/\s+/g, ''))) {
        return `‚ùå **Telefone inv√°lido!**

üìû Use o formato correto: **(11) 99999-9999**

Digite novamente:`;
      }

      conversation.agendamento_temp!.paciente_telefone = input;
      conversation.menu_state = 'agendar_confirmacao';
      
      return this.mostrarResumoAgendamento(conversation);
    }
  }

  /**
   * Mostra resumo do agendamento para confirma√ß√£o
   */
  private mostrarResumoAgendamento(conversation: Conversation): string {
    const dados = conversation.agendamento_temp!;
    
    return `üìã **CONFIRMA√á√ÉO DO AGENDAMENTO**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ü©∫ **Dados da Consulta:**
üë®‚Äç‚öïÔ∏è **M√©dico:** ${dados.medico_nome}
üè• **Especialidade:** ${dados.especialidade}
üìÖ **Data:** ${dados.data_selecionada}
‚è∞ **Hor√°rio:** ${this.agendamentoService.formatarHorario(dados.horario_selecionado!)}

üë§ **Dados do Paciente:**
ÔøΩ **Nome:** ${dados.paciente_nome}
üìû **Telefone:** ${dados.paciente_telefone}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ Para **CONFIRMAR**, digite: **CONFIRMAR**
‚ùå Para cancelar, digite: **0**

‚ö†Ô∏è **Importante:** Ap√≥s confirma√ß√£o, n√£o ser√° poss√≠vel alterar os dados.`;
  }

  /**
   * Processa confirma√ß√£o final
   */
  private async processarConfirmacao(mensagemDoUsuario: string, conversation: Conversation): Promise<string> {
    const input = mensagemDoUsuario.trim().toUpperCase();

    if (input !== 'CONFIRMAR') {
      return `‚ùå Para confirmar o agendamento, digite exatamente: **CONFIRMAR**
Para cancelar, digite: 0`;
    }

    try {
      const dados = conversation.agendamento_temp!;
      
      const protocolo = await this.agendamentoService.confirmarAgendamento(
        dados.agenda_id!,
        dados.paciente_nome!,
        dados.paciente_telefone!
      );

      // Limpar dados tempor√°rios
      conversation.agendamento_temp = {};
      conversation.menu_state = 'menu';

      return `üéâ **AGENDAMENTO CONFIRMADO COM SUCESSO!**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üé´ **PROTOCOLO:** ${protocolo}

ü©∫ **Resumo da Consulta:**
üë®‚Äç‚öïÔ∏è **M√©dico:** ${dados.medico_nome}
üè• **Especialidade:** ${dados.especialidade}
üìÖ **Data:** ${dados.data_selecionada}
‚è∞ **Hor√°rio:** ${this.agendamentoService.formatarHorario(dados.horario_selecionado!)}

üë§ **Paciente:**
ÔøΩ **Nome:** ${dados.paciente_nome}
üìû **Telefone:** ${dados.paciente_telefone}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è **INSTRU√á√ïES IMPORTANTES:**
‚Ä¢ ‚è∞ Chegue com **15 minutos** de anteced√™ncia
‚Ä¢ üÜî Traga **documento com foto**
‚Ä¢ üíæ **Guarde este protocolo:** ${protocolo}
‚Ä¢ üì± Em caso de d√∫vidas, entre em contato

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

${this.getMainMenu()}`;

    } catch (error) {
      console.error('[ChatService] Erro ao confirmar agendamento:', error);
      
      // Limpar dados tempor√°rios mesmo em caso de erro
      conversation.agendamento_temp = {};
      conversation.menu_state = 'menu';
      
      return `‚ùå Erro ao confirmar agendamento. O hor√°rio pode ter sido ocupado por outro paciente.

Tente fazer um novo agendamento.

${this.getMainMenu()}`;
    }
  }
}